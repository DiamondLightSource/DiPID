import h5py
import numpy as np
import matplotlib.pyplot as plt
from torch import Tensor, tensor

from sslm.utils.predictor import SSLPredictor
from tlm.utils.predictor import TLMPredictor


class JointPredictor:
    def __init__(self, ssl_sdp: str, tlm_sdp: str, threshold: float) -> None:
        """Create both predictors and set the confidence threshold

        Args:
            ssl_sdp (str): file containing the model weights for the self-supervised model
            tlm_sdp (str): file containing the model weights for the transfer model
            threshold (float): confidence threshold to accept transfer model predictions
        """
        self.SSLPred = SSLPredictor(ssl_sdp)
        self.TLMPred = TLMPredictor(tlm_sdp)

        self.threshold = threshold

    def predict_one_image(
        self,
        folder: str,
        nxs_no: str,
        img_no: int,
        use_nms=False,
        use_tlm=True,
        use_ssl=True,
    ) -> tuple[Tensor, list[Tensor]]:
        """Generate model predictions for a single input image

        Args:
            folder (str): folder containing the nexus file
            nxs_no (str): scan number of the nexus file
            img_no (int): image index within the scan data
            use_nms (bool, optional): whether to apply non-mas supression filtering to the transfer model outputs. Defaults to False.
            use_tlm (bool, optional): whether to generate transfer model predictions. Defaults to True.
            use_ssl (bool, optional): whether to generate self-supervised model predictions. Defaults to True.

        Returns:
            tuple[Tensor, list[Tensor]]: masks generated by the two models, or a 0 tensor if the model was not used
        """
        if use_ssl:
            ssl_masks = self.SSLPred.predict(folder, nxs_no, img_no)
        else:
            ssl_masks = tensor(0)
        if use_tlm:
            tlm_masks, tlm_boxes, tlm_scores = self.TLMPred.predict(
                folder, nxs_no, img_no, self.threshold, use_nms
            )
        else:
            tlm_masks = [tensor(0)]

        return ssl_masks, tlm_masks

    def predict_scan(
        self,
        folder: str,
        nxs_no: str,
        start_val=0,
        end_val=1000,
        use_tlm=True,
        use_ssl=True,
    ) -> tuple[dict, dict]:
        """Generate predictions for all images in a single nexus file

        Args:
            folder (str): folder containing the nexus file
            nxs_no (str): scan number of the nexus file
            start_val (int, optional): initial image number to run on. Defaults to 0.
            end_val (int, optional): final image number (not inclusive). Defaults to 1000.
            use_tlm (bool, optional): whether to generate transfer model predictions. Defaults to True.
            use_ssl (bool, optional): whether to generate self-supervised model predictions. Defaults to True.

        Returns:
            tuple[dict, dict]: dictionaries containing the predictions from each model, labelled by the scan number
        """
        filename = f"peak_detector/nexus/{folder}/{nxs_no}.nxs"
        with h5py.File(filename) as file:
            volume = file["entry1/pil3_100k/data"]
            scan_length = volume.shape[0]  # type: ignore
            print(f"{scan_length} images in scan")

        if end_val > scan_length:
            end_val = scan_length

        ssl_masks = {}
        tlm_masks = {}
        for scan in range(start_val, end_val):
            print(f"processing image {scan}/{end_val - 1}")
            masks = self.predict_one_image(
                folder, nxs_no, scan, use_tlm=use_tlm, use_ssl=use_ssl
            )
            ssl_masks[scan] = masks[0]
            tlm_masks[scan] = masks[1]

        return ssl_masks, tlm_masks

    def show_image_predictions(self, folder, nxs_no, img_no, use_nms=False):
        ssl_masks = self.SSLPred.predict(folder, nxs_no, img_no, show_img=True)
        tlm_masks, tlm_boxes, tlm_scores = self.TLMPred.predict(
            folder, nxs_no, img_no, self.threshold, use_nms
        )
        self.TLMPred.show_output(
            folder, nxs_no, img_no, tlm_masks, tlm_boxes, show_boxes=False
        )
        # potentially combine predictions to show on one output??

    def generate_3d_plot(self, masks: dict[int, np.ndarray], scan_type: str) -> None:
        """Compile all predictions from a scan into a 3d voxel volume

        Args:
            masks (dict[int, np.ndarray]): predictions for each image in a scan, indexed by their image number
            scan_type (str): which model generated the predictions
        """
        max_z = max(masks.keys())
        count = 0
        colors = np.ndarray((self.TLMPred.height, self.TLMPred.width, len(masks), 4))
        total = np.ndarray((self.TLMPred.height, self.TLMPred.width, max_z + 1))
        for scan_no, mask in masks.items():
            if scan_type == "tlm":
                allmasks = np.zeros(
                    (self.TLMPred.height, self.TLMPred.width), dtype=int
                )
                for m in mask:
                    allmasks = allmasks | m
                mask = allmasks
            elif scan_type == "ssl":
                mask = np.asarray(mask)
                mask = mask[:, :, 0]
            else:
                print(
                    "Scan type must be 'tlm' or 'ssl' depending on which model made the prediction"
                )

            total[:, :, scan_no] = mask

            colors[:, :, count, 0] = 0
            colors[:, :, count, 1] = count / len(masks)
            colors[:, :, count, 2] = 0.8
            colors[:, :, count, 3] = 0.5
            count += 1

        fig = plt.figure()
        ax = fig.add_subplot(projection="3d")
        ax.voxels(total, facecolors=colors)
        plt.xlim(0, self.TLMPred.height)
        plt.ylim(0, self.TLMPred.width)
        plt.show()


if __name__ == "__main__":
    jp = JointPredictor(
        "peak_detector/sslm/state_dicts/40.torch",
        "peak_detector/tlm/state_dicts/474.torch",
        0.4,
    )
    # ssl, tlm = jp.predict_one_image("mm24570-1", "794663", 25)
    jp.show_image_predictions("mm24570-1", "794663", 10)
    # ssl, tlm = jp.predict_scan("mm24570-1", "794663", use_ssl=False)
    # jp.generate_3d_plot(tlm, "tlm")
